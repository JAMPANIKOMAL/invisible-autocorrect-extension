# model_builder.py
# This script builds an advanced correction dictionary using a frequency list
# and an edit distance algorithm to generate potential misspellings.

import re

# --- Configuration ---

# --- Configuration ---
MASTER_DICTIONARY_FILE = 'assets/frequency_dictionary_en_82_765.txt'
OUTPUT_FILE = 'dictionary.js'
MAX_EDIT_DISTANCE = 1
# Only include corrections for the top N most frequent words
TOP_N_WORDS = 10000
# Limit the number of typos per word (most likely typos)
MAX_TYPOS_PER_WORD = 20

def generate_edits(word):
    """
    Generates all possible edits that are 1 edit distance away from the word.
    Includes deletions, transpositions, substitutions, and insertions.
    """
    letters    = 'abcdefghijklmnopqrstuvwxyz'
    splits     = [(word[:i], word[i:])    for i in range(len(word) + 1)]
    deletes    = [L + R[1:]               for L, R in splits if R]
    transposes = [L + R[1] + R[0] + R[2:] for L, R in splits if len(R)>1]
    replaces   = [L + c + R[1:]           for L, R in splits if R for c in letters]
    inserts    = [L + c + R               for L, R in splits for c in letters]
    return set(deletes + transposes + replaces + inserts)

def build_ai_dictionary():
    """
    Main function to build the dictionary.
    """
    print("--- Starting AI Model Builder ---")
    
    master_word_freq = {}
    correction_map = {}

    # --- Step 1: Load the Master Dictionary ---
    print(f"1. Loading master dictionary: '{MASTER_DICTIONARY_FILE}'...")
    try:
        with open(MASTER_DICTIONARY_FILE, 'r', encoding='utf-8') as f:
            for line in f:
                parts = line.strip().split()
                if len(parts) == 2:
                    word = parts[0].lower()
                    if word.isalpha():
                        master_word_freq[word] = int(parts[1])
    except FileNotFoundError:
        print(f"\n--- ERROR ---")
        print(f"Master dictionary file not found: '{MASTER_DICTIONARY_FILE}'")
        print("Please make sure it's in the same folder as this script.")
        return
    print(f"   Loaded {len(master_word_freq)} unique words.")

    # Sort and keep only the top N most frequent words
    sorted_words = sorted(master_word_freq.items(), key=lambda x: x[1], reverse=True)
    top_words = dict(sorted_words[:TOP_N_WORDS])
    print(f"   Using top {TOP_N_WORDS} words for corrections.")

    # --- Step 2: Generate Edits and Build Correction Map ---
    print(f"\n2. Generating misspellings (Edit Distance: {MAX_EDIT_DISTANCE})...")
    print("   This may take a few minutes...")
    
    total_words = len(top_words)
    for i, (correct_word, frequency) in enumerate(top_words.items()):
        if i % 1000 == 0:
            print(f"   Processed {i} / {total_words} words...")

        typos = list(generate_edits(correct_word))
        # Limit the number of typos per word
        typos = typos[:MAX_TYPOS_PER_WORD]

        for typo in typos:
            if typo not in top_words:
                if typo not in correction_map:
                    correction_map[typo] = correct_word
                else:
                    existing_correction = correction_map[typo]
                    if top_words.get(correct_word, 0) > top_words.get(existing_correction, 0):
                        correction_map[typo] = correct_word
    
    print(f"   Generated {len(correction_map)} unique corrections.")

    # --- Step 3: Write the Output File ---
    print(f"\n3. Writing output file: '{OUTPUT_FILE}'...")
    try:
        with open(OUTPUT_FILE, 'w', encoding='utf-8') as outfile:
            outfile.write("// This file was auto-generated by model_builder.py\n")
            outfile.write("// AI-powered correction map.\n\n")
            outfile.write("const correctionMap = {\n")
            
            for misspelled, corrected in correction_map.items():
                misspelled_escaped = misspelled.replace('"', '\\"')
                corrected_escaped = corrected.replace('"', '\\"')
                outfile.write(f'    "{misspelled_escaped}": "{corrected_escaped}",\n')

            outfile.write("};\n")
    except Exception as e:
        print(f"   Error writing file: {e}")
        return

    print("\n--- Success! ---")
    print("AI model building complete.")
    print(f"Your new dictionary has been saved to '{OUTPUT_FILE}'.")

# --- Run the script ---
if __name__ == "__main__":
    build_ai_dictionary()

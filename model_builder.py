# model_builder.py
# This script builds an advanced correction dictionary using a frequency list
# and an edit distance algorithm to generate potential misspellings.

import re

# --- Configuration ---
# The master dictionary file with word frequencies.
MASTER_DICTIONARY_FILE = 'frequency_dictionary_en_82_765.txt' 
# The output file for our new, AI-generated dictionary.
OUTPUT_FILE = 'dictionary_v2.js'
# The maximum edit distance for generating typos. 
# 1 is fast and effective. 2 is much more comprehensive but significantly slower.
MAX_EDIT_DISTANCE = 1 

def generate_edits(word):
    """
    Generates all possible edits that are 1 edit distance away from the word.
    Includes deletions, transpositions, substitutions, and insertions.
    """
    letters    = 'abcdefghijklmnopqrstuvwxyz'
    splits     = [(word[:i], word[i:])    for i in range(len(word) + 1)]
    deletes    = [L + R[1:]               for L, R in splits if R]
    transposes = [L + R[1] + R[0] + R[2:] for L, R in splits if len(R)>1]
    replaces   = [L + c + R[1:]           for L, R in splits if R for c in letters]
    inserts    = [L + c + R               for L, R in splits for c in letters]
    return set(deletes + transposes + replaces + inserts)

def build_ai_dictionary():
    """
    Main function to build the dictionary.
    """
    print("--- Starting AI Model Builder ---")
    
    master_word_freq = {}
    correction_map = {}

    # --- Step 1: Load the Master Dictionary ---
    print(f"1. Loading master dictionary: '{MASTER_DICTIONARY_FILE}'...")
    try:
        with open(MASTER_DICTIONARY_FILE, 'r', encoding='utf-8') as f:
            for line in f:
                # The format is 'word count'
                parts = line.strip().split()
                if len(parts) == 2:
                    word = parts[0].lower()
                    # Only include alphabetic words to keep it clean
                    if word.isalpha():
                        master_word_freq[word] = int(parts[1])
    except FileNotFoundError:
        print(f"\n--- ERROR ---")
        print(f"Master dictionary file not found: '{MASTER_DICTIONARY_FILE}'")
        print("Please make sure it's in the same folder as this script.")
        return
        
    print(f"   Loaded {len(master_word_freq)} unique words.")

    # --- Step 2: Generate Edits and Build Correction Map ---
    print(f"\n2. Generating misspellings (Edit Distance: {MAX_EDIT_DISTANCE})...")
    print("   This may take a few minutes...")
    
    total_words = len(master_word_freq)
    for i, (correct_word, frequency) in enumerate(master_word_freq.items()):
        # Print progress indicator
        if i % 5000 == 0:
            print(f"   Processed {i} / {total_words} words...")

        # Generate all possible typos for the current correct word
        typos = generate_edits(correct_word)
        if MAX_EDIT_DISTANCE > 1:
            typos.update(e2 for e1 in typos for e2 in generate_edits(e1))

        for typo in typos:
            # If the typo isn't a real word itself...
            if typo not in master_word_freq:
                # If this typo hasn't been seen before, assign the current word to it.
                if typo not in correction_map:
                    correction_map[typo] = correct_word
                else:
                    # If this typo is already in our map, it's a conflict.
                    # We need to decide which correction is better.
                    # We do this by checking which correct word is more common (higher frequency).
                    existing_correction = correction_map[typo]
                    if master_word_freq.get(correct_word, 0) > master_word_freq.get(existing_correction, 0):
                        correction_map[typo] = correct_word
    
    print(f"   Generated {len(correction_map)} unique corrections.")

    # --- Step 3: Write the Output File ---
    print(f"\n3. Writing output file: '{OUTPUT_FILE}'...")
    try:
        with open(OUTPUT_FILE, 'w', encoding='utf-8') as outfile:
            outfile.write("// This file was auto-generated by model_builder.py\n")
            outfile.write("// AI-powered correction map.\n\n")
            outfile.write("const correctionMap = {\n")
            
            for misspelled, corrected in correction_map.items():
                misspelled_escaped = misspelled.replace('"', '\\"')
                corrected_escaped = corrected.replace('"', '\\"')
                outfile.write(f'    "{misspelled_escaped}": "{corrected_escaped}",\n')

            outfile.write("};\n")
    except Exception as e:
        print(f"   Error writing file: {e}")
        return

    print("\n--- Success! ---")
    print("AI model building complete.")
    print(f"Your new dictionary has been saved to '{OUTPUT_FILE}'.")

# --- Run the script ---
if __name__ == "__main__":
    build_ai_dictionary()
